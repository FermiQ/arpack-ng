## Overview
The `zneupd` subroutine is the double-precision complex counterpart to `cneupd`. It is called after `znaupd` (the double-precision complex Arnoldi iteration routine) has successfully converged. `zneupd`'s primary role is to return the converged approximations to eigenvalues (Ritz values) of the eigenvalue problem A*z = lambda*B*z. Additionally, it can optionally compute:
1. The corresponding approximate eigenvectors (Ritz vectors).
2. An orthonormal basis for the associated approximate invariant subspace (Schur vectors).
3. Both Ritz and Schur vectors.

The quantities computed by `zneupd` are derived from the Arnoldi factorization generated by `znaupd` for the complex linear operator OP (which is defined by the `MODE` selection in `znaupd`). `zneupd` also handles the transformation of these OP-related values and vectors back to the original problem's eigensystem, which is essential if a shift-and-invert strategy was used during the `znaupd` phase.

## Key Components
- **`zneupd` (subroutine):** The main routine for processing the results from a converged `znaupd` run. It computes double-precision complex Ritz values and, if requested, Ritz vectors or Schur vectors. This includes performing necessary transformations from the operator OP's domain (used in `znaupd`) back to the original problem A*z = lambda*B*z.

## Important Variables/Constants
- **`RVEC` (LOGICAL, INPUT):**
    - `.FALSE.`: Compute Ritz values only.
    - `.TRUE.`: Compute Ritz vectors or Schur vectors.
- **`HOWMNY` (Character*1, INPUT):** Specifies the form of the basis for the invariant subspace.
    - `'A'`: Compute all NEV Ritz vectors.
    - `'P'`: Compute all NEV Schur vectors.
    - `'S'`: Compute a selection of Ritz vectors (as specified by the `SELECT` array). (Note: `'S'` mode might not be fully implemented in all ARPACK versions).
- **`SELECT` (Logical array, INPUT/WORKSPACE):** If `HOWMNY = 'S'`, this array indicates which Ritz vectors are to be computed. It's used as workspace if `HOWMNY = 'A'` or `'P'`.
- **`D` (Complex*16 array, OUTPUT):** Array of dimension NEV (or NEV+1 in some older docs, typically NEV is used for converged values) that will contain the Ritz value approximations to the eigenvalues of A*z = lambda*B*z.
- **`Z` (Complex*16 array, OUTPUT):** An N by NEV array. If `RVEC = .TRUE.` and `HOWMNY = 'A'`, this array will hold the Ritz vectors corresponding to the eigenvalues in `D`.
- **`LDZ` (Integer, INPUT):** Leading dimension of the array `Z`.
- **`SIGMA` (Complex*16, INPUT):** The shift value that was used in `znaupd` if `IPARAM(7)` (MODE) was 3 (shift-and-invert). It's not referenced if Mode 1 or 2 was used.
- **`WORKEV` (Complex*16 array, WORKSPACE):** A work array of dimension 2*NCV.
- **`BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR, WORKD, WORKL, LWORKL, RWORK, INFO`:** These arguments *must* be identical to those passed to the final successful call of `znaupd`. They must not be modified between the `znaupd` call and the `zneupd` call.

    - **`V` (Complex*16 array, INPUT/OUTPUT):** On input, this N by NCV array contains the Arnoldi basis vectors from `znaupd`. On output (if `RVEC = .TRUE.`), its first `NCONV=IPARAM(5)` columns will contain approximate Schur vectors. If `Z` shares the same memory space as `V` and Ritz vectors (`HOWMNY='A'`) are requested, then `V` will be overwritten by the Ritz vectors.
    - **`WORKL` (Complex*16 array, OUTPUT/WORKSPACE):** This array contains data from `znaupd` and is further utilized and populated by `zneupd`. Specific pointers in `IPNTR` (e.g., `IPNTR(9)`, `IPNTR(11)`, `IPNTR(12)`, `IPNTR(13)`) map to locations within `WORKL` where `zneupd` stores/retrieves Ritz values of the original system, error bounds, the Schur matrix T, and the eigenvector matrix of the Hessenberg matrix H.
    - **`RWORK` (Double precision array, WORKSPACE):** A real-valued work array passed from `znaupd`.
    - **`INFO` (Integer, OUTPUT):** Error flag. Key values include:
        - `1`: Failure in reordering the Schur form by LAPACK routine `ztrsen`.
        - `-8`: Error during LAPACK eigenvalue calculation (e.g., `zlahqr`).
        - `-9`: Error during LAPACK eigenvector calculation (e.g., `ztrevc`).
        - `-14`: `znaupd` did not find any eigenvalues to the required accuracy.
        - `-15`: A mismatch occurred in the count of converged Ritz values between `znaupd` and `zneupd`.

## Usage Examples
`zneupd` is called after `znaupd` has successfully converged (indicated by `INFO = 0` from `znaupd`).

```fortran
C ... (previous znaupd reverse communication loop) ...

      IF (INFO .EQ. 0) THEN
C        znaupd has converged, proceed to call zneupd
         RVEC = .TRUE.      ! Indicate that vectors are desired
         HOWMNY = 'A'       ! Specify that Ritz vectors are to be computed

         CALL ZNEUPD ( RVEC, HOWMNY, SELECT, D, Z, LDZ, SIGMA, WORKEV,
     & BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV,
     & IPARAM, IPNTR, WORKD, WORKL, LWORKL, RWORK, INFO_EUPD )

         IF (INFO_EUPD .EQ. 0) THEN
C           Successfully retrieved D (eigenvalues)
C           and Z (eigenvectors, if RVEC=.TRUE. and HOWMNY='A')
C           Proceed to process the results...
         ELSE
C           An error occurred in zneupd
         END IF
      ELSE
C        znaupd did not converge or an error occurred
      END IF
```
For complete and runnable examples, consult the `EXAMPLES/COMPLEX` directory in the ARPACK source code distribution, with `zndrv1.f` being the relevant driver for double-precision complex problems. The `ex-complex.doc` file (if available) also provides useful context.

## Dependencies and Interactions
- **Internal ARPACK routines called:**
    - `ivout`: Utility for printing integers.
    - `zmout`: Utility for printing double-precision complex matrices.
    - `zvout`: Utility for printing double-precision complex vectors.
- **LAPACK routines called:**
    - `zgeqr2`: Computes the QR factorization of a complex matrix.
    - `zlacpy`: Copies a complex matrix.
    - `zlahqr`: Computes the Schur form of a complex upper Hessenberg matrix.
    - `zlaset`: Initializes a complex matrix.
    - `ztrevc`: Computes eigenvectors of a complex upper triangular matrix.
    - `ztrsen`: Reorders the Schur form of a complex matrix.
    - `zunm2r`: Multiplies by a unitary matrix formed by `zgeqr2`.
    - `dlamch`: Determines machine constants (double precision).
- **BLAS routines called:**
    - `ztrmm` (Level 3): Performs matrix-matrix operations involving triangular matrices.
    - `zgeru` (Level 2): Performs a rank-1 update of a general complex matrix (unsymmetric).
    - `zcopy` (Level 1): Copies a complex vector.
    - `zscal` (Level 1): Scales a complex vector by a complex scalar.
    - `zdscal` (Level 1): Scales a complex vector by a real scalar.
    - `dznrm2` (Level 1): Computes the 2-norm of a complex vector (result is double precision).
    - `zzdotc` (Level 1): Computes the dot product of two complex vectors, conjugating the first.
- **Interactions:**
    - `zneupd` is critically dependent on a prior successful execution of `znaupd`.
    - It requires the exact same set of arguments as were passed to `znaupd`, and these must not be altered between the calls.
    - The `WORKL` (Complex*16) and `RWORK` (Double precision) arrays are vital as they carry information from `znaupd` (such as the Hessenberg matrix H) and are used by `zneupd` to store intermediate and final results (like the Schur form T, eigenvectors of H, and the transformed Ritz values/vectors).
    - The `IPNTR` array provides crucial offsets for accessing data within `WORKL`.
    - If `RVEC = .TRUE.`, the `V` array is modified: it will contain Schur vectors, or Ritz vectors if `Z` and `V` share the same memory and `HOWMNY='A'`.
    - When shift-and-invert mode (`IPARAM(7)=3`) was used in `znaupd`, the `SIGMA` parameter is used by `zneupd` to transform the eigenvalues from the operator OP's system (related by 1/(lambda-sigma)) back to the eigenvalues (lambda) of the original problem A*z=lambda*B*z. Ritz vectors are generally invariant under this transformation but may undergo a purification step.
```
