## Overview
The `dneupd` subroutine is called after `dnaupd` has converged. Its primary function is to return the converged approximations to eigenvalues (Ritz values) of the non-symmetric eigenvalue problem A*z = lambda*B*z. Optionally, it can also compute:
1. The corresponding approximate eigenvectors (Ritz vectors).
2. An orthonormal basis for the associated approximate invariant subspace (Schur vectors).
3. Both Ritz and Schur vectors.

The computed quantities are derived from the Arnoldi factorization generated by `dnaupd` for the linear operator OP (defined by the `MODE` selection in `dnaupd`). `dneupd` transforms these OP-related values and vectors back to the original problem A*z = lambda*B*z if necessary (e.g., for shift-and-invert modes).

## Key Components
- **`dneupd` (subroutine):** The main routine for extracting and processing the results from a converged `dnaupd` run. It computes Ritz values, and optionally Ritz vectors or Schur vectors, handling transformations from the OP domain to the original problem domain.

## Important Variables/Constants
- **`RVEC` (LOGICAL, INPUT):**
    - `.FALSE.`: Compute Ritz values only.
    - `.TRUE.`: Compute Ritz vectors or Schur vectors.
- **`HOWMNY` (Character*1, INPUT):** Specifies the form of the basis for the invariant subspace.
    - `'A'`: Compute NEV Ritz vectors.
    - `'P'`: Compute NEV Schur vectors.
    - `'S'`: Compute selected Ritz vectors (specified by `SELECT`). (Note: `'S'` might not be fully implemented in all versions).
- **`SELECT` (Logical array, INPUT/WORKSPACE):** If `HOWMNY = 'S'`, marks specific Ritz vectors for computation. Workspace otherwise.
- **`DR` (Double precision array, OUTPUT):** Real parts of the computed Ritz values. For complex shifts (`SIGMAI != 0` with Mode 3 or 4), these might be Ritz values of OP; see Remarks in source.
- **`DI` (Double precision array, OUTPUT):** Imaginary parts of the computed Ritz values. Complex Ritz values appear in conjugate pairs.
- **`Z` (Double precision array, OUTPUT):** If `RVEC = .TRUE.` and `HOWMNY = 'A'`, contains the Ritz vectors. For a complex Ritz pair (a+ib, a-ib), the vector for a+ib is stored as real part in column `j` and imaginary part in column `j+1`. The vector for a-ib is the conjugate.
- **`LDZ` (Integer, INPUT):** Leading dimension of `Z`.
- **`SIGMAR`, `SIGMAI` (Double precision, INPUT):** Real and imaginary parts of the shift `sigma`, used if `IPARAM(7)` (MODE in `dnaupd`) was 3 or 4.
- **`WORKEV` (Double precision array, WORKSPACE):** Work array of dimension 3*NCV.
- **`BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR, WORKD, WORKL, LWORKL, INFO`:** These arguments *must* be identical to those from the last successful call to `dnaupd`. They should not be modified.

    - **`V` (Double precision array, INPUT/OUTPUT):** On input, Arnoldi basis from `dnaupd`. On output (if `RVEC = .TRUE.`), first `NCONV=IPARAM(5)` columns contain Schur vectors. If `Z` shares space with `V` and Ritz vectors are requested, `V` is overwritten by Ritz vectors.
    - **`WORKL` (Double precision array, OUTPUT/WORKSPACE):** Contains data from `dnaupd` and results from `dneupd`. `IPNTR(9:13)` point to locations for original system Ritz values (real/imag), error bounds, Schur matrix, and eigenvector matrix of H.
    - **`INFO` (Integer, OUTPUT):** Error flag. Specific values indicate issues, e.g.:
        - `1`: Schur form reordering failed.
        - `-8`: Error in LAPACK `dlahqr` (Schur form computation).
        - `-9`: Error in LAPACK `dtrevc` (eigenvector computation).
        - `-14`: `dnaupd` found no eigenvalues.
        - `-15`: Discrepancy in converged Ritz value count between `dnaupd` and `dneupd`.

## Usage Examples
`dneupd` is called *after* `dnaupd` has converged (typically `INFO = 0` from `dnaupd`).

```fortran
c ... (previous dnaupd reverse communication loop) ...

      IF (INFO .EQ. 0) THEN
C        dnaupd converged, call dneupd
         RVEC = .TRUE.      ! Request vectors
         HOWMNY = 'A'       ! Request Ritz vectors

         CALL DNEUPD ( RVEC, HOWMNY, SELECT, DR, DI, Z, LDZ, SIGMAR, SIGMAI,
     & WORKEV, BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV,
     & IPARAM, IPNTR, WORKD, WORKL, LWORKL, INFO_EUPD )

         IF (INFO_EUPD .EQ. 0) THEN
C           Successfully retrieved DR, DI (eigenvalues)
C           and Z (eigenvectors if RVEC=.TRUE., HOWMNY='A')
C           Process results...
         ELSE
C           Error in dneupd
         END IF
      ELSE
C        Error or other condition in dnaupd
      END IF
```
Refer to ARPACK `EXAMPLES/NONSYM` directory for files like `dndrv1.f` (standard problems) or `dndrv2.f` (generalized problems) for complete usage scenarios. The `ex-nonsym.doc` file also provides valuable context.

**Important Note on Shift-and-Invert (Mode 3, 4 with SIGMAI != 0.0):**
If a complex shift `sigma` was used, `dneupd` might return Ritz values/vectors for the operator OP. The user might need to perform a Rayleigh Quotient projection to get the eigenvalues of the original system A*z = lambda*B*z. See Remark 3 in the `dneupd.f` source code for details.

## Dependencies and Interactions
- **Internal ARPACK routines called:**
    - `ivout`: Prints integers.
    - `dmout`: Prints matrices.
    - `dvout`: Prints vectors.
- **LAPACK routines called:**
    - `dgeqr2`: QR factorization.
    - `dlacpy`: Matrix copy.
    - `dlahqr`: Real Schur form of Hessenberg matrix.
    - `dlamch`: Machine constants.
    - `dlapy2`: Computes sqrt(x^2+y^2).
    - `dlaset`: Matrix initialization.
    - `dorm2r`: Applies orthogonal matrix.
    - `dtrevc`: Eigenvectors of upper quasi-triangular matrix.
    - `dtrsen`: Reorders Schur form.
- **BLAS routines called:**
    - `dtrmm` (Level 3): Matrix-triangular matrix product.
    - `dger` (Level 2): Rank-one update.
    - `dcopy` (Level 1): Vector copy.
    - `ddot` (Level 1): Dot product.
    - `dnrm2` (Level 1): Vector norm.
    - `dscal` (Level 1): Vector scale.
- **Interactions:**
    - `dneupd` is critically dependent on a prior successful run of `dnaupd`.
    - It uses many of the same arguments, which must remain unchanged.
    - `WORKL` is heavily used to pass data from `dnaupd` (like the Hessenberg matrix H) and store `dneupd`'s results (Schur form, eigenvectors of H, transformed Ritz values/vectors).
    - `IPNTR` array is essential for locating data within `WORKL`.
    - If `RVEC = .TRUE.`, `V` is modified to contain Schur vectors, or Ritz vectors if `Z` points to `V`.
    - For shift-and-invert modes (`IPARAM(7)=3,4`), `SIGMAR` and `SIGMAI` are used to transform Ritz values/vectors from the OP system back to the original A*z=lambda*B*z system. This transformation might require user intervention for complex shifts (see Remark 3 in `dneupd.f`).
```
